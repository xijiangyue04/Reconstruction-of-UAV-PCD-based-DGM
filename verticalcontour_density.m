%第一步：输入：墙面分割的平面点云plane_segment，number_of_neighbor 最邻近点数
%确定每个分割平面竖向边界点的横向和纵向密度最大的，且相距较远的定位点
%说白了就是要确定边界点的主体轮廓框架定位点及定位方向向量
%输出：sort_R代表墙面横向和竖向的所有点密度，boundary_pnts 墙面点云轮廓点，line_vector：墙面横向和竖向向量
function [sort_R,boundary_pnts,line_vector,project_pnt] = verticalcontour_density(plane_segment,number_of_neighbor,dist_thr)


[parameter] = TLS_Plane(plane_segment);
[project_pnt] = pntplane_projection(plane_segment,parameter) ;
project_pnt=project_pnt';
[boundary_pnts] = boundary_extract2(project_pnt,number_of_neighbor) ;
vect1=parameter(1:3,:)';%分割面的法向量
vect2=[0,0,1];%这是基准向量
line_vector1=cross(vect1,vect2);%与基准向量和分割面向量的垂直向量
line_vector2=cross(line_vector1,vect1);
line_vector=[line_vector1;line_vector2];
n=size(boundary_pnts,1);

for j=1:size(line_vector,1)
     
for i=1:n
    dist= PL_distance_TLS(boundary_pnts, boundary_pnts(i,:), line_vector(j,:)); %点-线距离
    pnt_inter=boundary_pnts(dist<dist_thr,:);%其他点到线的距离范围小于0.1的点数
    if size(pnt_inter,1)>5 %该线范围大于5个点才需要进行密度计算
    scale=sqrt(sum(boundary_pnts(i,:).^2));%利用点的距离来描述扫描点云的尺度，尺度很大的情况下比如10^6,与一个小的向量相加会出现结果没变化,所以要乘以尺度
    line_pnt1=boundary_pnts(i,:);%
    line_pnt2=line_pnt1+scale*line_vector(j,:);
    linepnt=[line_pnt1;line_pnt2];
    [PL_projection] = pntline_projection(linepnt,pnt_inter);
    pnt_distrib_index(i,:) = linepnt_distribution(PL_projection) ;%线上点的密度指数，采用中误差及均值表达,越小越好
      k(i,:)=size(pnt_inter,1);
    else
        pnt_distrib_index(i,:)=[inf,inf];
        k(i,:)=0;
    end
end

v1=pnt_distrib_index(:,1);v2=pnt_distrib_index(:,2);
inf_indices1 =~isinf(v1);inf_indices2 =~isinf(v2);
max_index1=max(v1(inf_indices1));max_index2=max(v2(inf_indices2));
     
norm1=[pnt_distrib_index(:,1)/max_index1,pnt_distrib_index(:,2)/max_index2];   %越小越好
norm11=sum(1./exp(norm1),2);
density1_norm=norm11./max(norm11);
density2_norm=k/max(k); %越大越好
density=density1_norm+density2_norm;
density(:,2)=1:n'; %第二列赋予标签号
linedensity= sortrows(density,-1);  %密度从大到小排序，第一列是密度大小排序，第二列是标签号
 
for i=1:n
            outlinepnt=boundary_pnts(linedensity(i,2),:);  
            line_pnts=boundary_pnts;
            line_vectors=repmat(line_vector(j,:),n,1);
        if linedensity(i,1)==max(linedensity(:,1))
            D= PLines_distance_TLS(outlinepnt, line_pnts, line_vectors); %单个点到多个直线距离
            max_D=max(D);
            delta(i,:)=max_D;
        else
            index_no=linedensity(1:i-1,2);%前面较小离散的行号
            D= PLines_distance_TLS(outlinepnt, line_pnts(index_no,:), line_vectors(index_no,:));
            min_D=min(D);
            delta(i,:)=min_D;
        end
end
DD2=2*delta/max(delta);
rr=[linedensity(:,2),linedensity(:,1).*DD2];
sort_R{j}=sortrows(rr,-2);
end

